# 面向对象

使用设计模式是已经验证的一种正确的编程方式。但是要搞清楚主次，以及我们为什么要使用设计模式。

例如，为了实现高内聚，低耦合，我们通常要求使用接口。接口是对一系列行为总结归纳之后的结果，人类习惯先有实践，然后才能根据实践总结出通用的经验。所以在编程的时候不要强求一定要一开始就设计接口，而是先进行实现类设计，然后把需要开放给外部调用方使用的“能力”当作接口开放出去。

# 单元测试

经常有人提到看起来很美的TDD，由高级的程序员，先设计好一个功能实现的目标，然后再有低级程序员去完成实现。但是即使再有经验的人，仍旧有犯错的地方，特别是在单元测试这种要求尽量充分覆盖所有情况的工作当中。

所以，我一般变成仍旧是先做实现，然后根据实现中的相关经验，能够归纳出来几个常见的单元测试场景。

在后续代码的联合调试中，一旦遇到某个单元出现bug，需要把这种情况抽离成一种单元测试用例，在这样的一个过程中，一步步完善你的代码。

难以想象在一个稍微复杂的算法中，没有单元测试如何确保算法的正确性。

# MySQL

做了读写分离的情况下，如果没有做特殊处理，直连查询的话。那么业务上就必须接受可能存在刚刚保存的数据，后续的请求无法查询到的情况。

针对这种问题：
1、订阅MySQL，binlog等到主库同步完了，再查从库
2、说服业务上要接受
3、在一次请求中，避免先保存后查询的情况，如果必须这样做，后续查询需要手动控制使用同一个数据源。例如都在writer dao中查询。

# 多线程

## 定时终止线程

控制线程超时，适用Future的get方法，有TimeoutException可以用来控制线程超时。

适用Thread.interrupt，需要自己判断线程状态来终止线程状态。

但是要注意，get方法是在调用的时候开始计时，所以，如果使用了线程池，线程到了Queue中，排队时间也会算在超时时间里面！

这时候需要用一个线程安全的变量，来判断线程是否已经开始执行。

## 获取当前执行的线程对象



如果我们new 一个Thread，名字未thread。

使用线程池执行，service.execute(thread)

在这个thread的run()方法中，如何获取当前执行的线程对象呢？

一开始我想当然的一位直接使用this就可以了，但是发现他的getState状态一直为NEW，说明执行的不是这个线程。这时候我想当然的以为，肯定是线程池自己维护了Thread对象，因为service.execute的入参是Runnable。

经过看线程池的代码，发现的确如此。我们使用this可以获取到thread对象，是因为Thread也实现了Runnable。但是线程池只是把它当作入参来使用，并没有使用这个线程对象。

如果想要获取当前执行的线程，还是应该使用 Thread.currentThread